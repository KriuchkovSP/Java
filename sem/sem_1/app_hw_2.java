//2. Реализовать алгоритм пирамидальной сортировки (HeapSort)

public class app_hw_2 {
    public static void main(String[] args){
        int arr[] = {17, 21, 18, 15, 2, 0, 14};

        app_hw_2 ob = new app_hw_2(); // объявляем новый класс
        ob.sort(arr); // Передаем на сортировку массив

        System.out.println("Результат сортировки методом HeapSort:");
        printArray(arr);
    }
    public void sort(int arr[])
    {
        int n = arr.length; // 7

        // перегруппируем массив
        for (int i = n / 2 - 1; i >= 0; i--) // Перебираем от середины массива до начала
            heapify(arr, n, i); // вызываем функцию преобразования в двоичную кучу
            // Передали в функцию:
            // 1 итерация: arr = {17, 21, 18, 15, 2, 0, 14}, n = 7, i = 2
            // 2 итерация: arr = {17, 21, 18, 15, 2, 0, 14}, n = 7, i = 1
            // 3 итерация: arr = {17, 21, 18, 15, 2, 0, 14}, n = 7, i = 0
            // 4 итерация была в рекурсии

        // Один за другим извлекаем все элементы из кучи, начинаем с конца
        // После 4 итераций массив имеет следующий вид:
        // {21, 17, 18, 15, 2, 0, 14}
        // {18, 17, 14, 15, 2, 0, 21}
        for (int i = n - 1; i >= 0; i--)
        {
            // Перемещаем текущий корень в конец
            int temp = arr[0]; // i = 6, temp = 21; i = 5, temp = 18
            arr[0] = arr[i]; // arr[0] = 14; arr[0] = 0
            arr[i] = temp; // arr[6] = 21, arr[5] = 18
            //{14, 17, 18, 15, 2, 0, 21}
            //{0, 17, 14, 15, 2, 18, 21}

            // Вызываем процедуру heapify на уменьшенной куче
            heapify(arr, i, 0);
            // передаем arr = {14, 17, 18, 15, 2, 0, 21}, i = 6, 0
            // передаем arr = {0, 17, 14, 15, 2, 18, 21}, i = 5, 0
        }
    }

    // Процедура для преобразования в двоичную кучу поддерева с корневым узлом i, что является
// индексом в arr[]. n - размер кучи
     void heapify(int arr[], int n, int i)
    {
        // 
        int largest = i; // Инициализируем наибольший элемент как корень
        int l = 2*i + 1; // левый = 2*i + 1
        int r = 2*i + 2; // правый = 2*i + 2
        // {17, 21, 18, 15, 2, 0, 14}
        // 1 итерация: largest = 2, l = 5, r = 6
        //      arr[5] = 0, arr[6] = 14, arr[2] = 18
        // 2 итерация: largest = 1, l = 3, r = 4
        //      arr[3] = 15, arr[4] = 2, arr[1] = 21
        // 3 итерация: largest = 0, l = 1, r = 2
        //      arr[1] = 21, arr[2] = 18, arr[0] = 17
        // рекурсивный вызов
        // 4 итерация: arr = {21, 17, 18, 15, 2, 0, 14}
        // largest = 1, l = 3, r = 4
        //      arr[3] = 15, arr[4] = 2, arr[1] = 17
        // 5 итерация: arr = {14, 17, 18, 15, 2, 0, 21}, n = 6, i = 0
        //      largest = 0, l = 1, r = 2
        //      arr[1] = 17, arr[2] = 18, arr[0] = 14
        // 6 итерация: arr = {18, 17, 14, 15, 2, 0, 21}, n = 6, i = 2
        //      largest = 2, l = 5, r = 6
        //      arr[5] = 0, arr[6] = 21, arr[2] = 14

        // Если левый дочерний элемент больше корня
        if (l < n && arr[l] > arr[largest])
            largest = l;
        // 1 итерация: условие не выполняется 0 < 18
        // 2 итерация: условие не выполняется 15 < 21
        // 3 итерация: условие выполняется 21 > 17, largest = 1
        // 4 итерация: условие не выполняется 15 < 17
        // 5 итерация: выполняется 17 > 14, largest = 1
        // 6 итерация: не выполняется 0 < 14

        // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
        if (r < n && arr[r] > arr[largest])
            largest = r;
        // 1 итерация: условие не выполняется 14 < 18
        // 2 итерация: условие не выполняется 2 < 21
        // 3 итерация: условие не выполняется 18 < 21
        // 4 итерация: условие не выполняется 2 < 17
        // 5 итерация: выполняется 18 > 17, largest = 2
        // 6 итерация: не выполняется r = 6 n = 6, r < n

       // Если самый большой элемент не корень
        if (largest != i)
        {
            int swap = arr[i]; // swap = 14
            arr[i] = arr[largest]; // arr[0] = 18
            arr[largest] = swap; // arr[1] = 14
            // Рекурсивно преобразуем в двоичную кучу затронутое поддерево
            heapify(arr, n, largest);
        }
        // 1 итерация: условие не выполняется largest не изменился, т.е. = i (2)
        // 2 итерация: условие не выполняется largest не изменился, т.е. = i (1)
        // 3 итерация: условие выполняется largest = 1, a i = 0
        //      изменяем массив, помещая наибольший в начало из рассматриваемых трех элементов
        //      arr = {21, 17, 18, 15, 2, 0, 14}
        //      рекурсивно вызываем heapify со следующими параметрами:
        //      arr = {21, 17, 18, 15, 2, 0, 14}, n = 7, largest = 1 (запуск 4 итерации)
        // 4 итерация: условие не выполняется largest не изменился, т.е. = i (1)
        // 5 итерация: вызываем heapify: arr = {18, 17, 14, 15, 2, 0, 21}, n = 6, largest = 2 (запуск 6 итерации)
        // 6 итерация: условие не выполняется largest не изменился, т.е. = i (2)
    }

    // вывод на экран массива
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i]+" ");
        System.out.println();
    }

}
